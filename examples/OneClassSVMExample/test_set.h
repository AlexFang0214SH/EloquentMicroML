#pragma once

namespace Eloquent {
    namespace ML {
        namespace Test {
            class TestSet {
            public:
                TestSet() :
                    _x{
                        {   2.155007372  ,  2.320100047  },
                        {   2.158857681  ,  2.155951003  },
                        {   1.857081415  ,  1.672209019  },
                        {   2.247826643  ,  2.389223989  },
                        {   2.300647368  ,  2.192515116  },
                        {   1.64918076  ,  1.573249313  },
                        {   2.322355879  ,  1.766074565  },
                        {   1.256809336  ,  1.724274643  },
                        {   2.019996606  ,  1.49907968  },
                        {   1.24430735  ,  2.022525555  },
                        {   2.12736108  ,  2.267282459  },
                        {   1.896671298  ,  2.176281137  },
                        {   1.894652561  ,  2.095931058  },
                        {   2.266280128  ,  1.807391808  },
                        {   2.369772571  ,  2.061721849  },
                        {   2.507733043  ,  2.066361445  },
                        {   1.766032738  ,  2.294740627  },
                        {   1.883977114  ,  2.36828571  },
                        {   2.065965838  ,  2.264659676  },
                        {   1.388084106  ,  2.028891487  },
                        {   -1.844992628  ,  -1.679899953  },
                        {   -1.841142319  ,  -1.844048997  },
                        {   -2.142918585  ,  -2.327790981  },
                        {   -1.752173357  ,  -1.610776011  },
                        {   -1.699352632  ,  -1.807484884  },
                        {   -2.35081924  ,  -2.426750687  },
                        {   -1.677644121  ,  -2.233925435  },
                        {   -2.743190664  ,  -2.275725357  },
                        {   -1.980003394  ,  -2.50092032  },
                        {   -2.75569265  ,  -1.977474445  },
                        {   -1.87263892  ,  -1.732717541  },
                        {   -2.103328702  ,  -1.823718863  },
                        {   -2.105347439  ,  -1.904068942  },
                        {   -1.733719872  ,  -2.192608192  },
                        {   -1.630227429  ,  -1.938278151  },
                        {   -1.492266957  ,  -1.933638555  },
                        {   -2.233967262  ,  -1.705259373  },
                        {   -2.116022886  ,  -1.63171429  },
                        {   -1.934034162  ,  -1.735340324  },
                        {   -2.611915894  ,  -1.971108513  },
                    },
                    _y{    0  ,  0  ,  0  ,  0  ,  0  ,  0  ,  0  ,  0  ,  0  ,  0  ,  0  ,  0  ,  0  ,  0  ,  0  ,  0  ,  0  ,  0  ,  0  ,  0  ,  1  ,  1  ,  1  ,  1  ,  1  ,  1  ,  1  ,  1  ,  1  ,  1  ,  1  ,  1  ,  1  ,  1  ,  1  ,  1  ,  1  ,  1  ,  1  ,  1   },
                    _tp(0),
                    _tn(0),
                    _fp(0),
                    _fn(0)
                {}

                template<class Classifier>
                void test(Classifier clf) {
                    for (uint16_t i = 0; i < 40; i++) {
                        int predicted = clf.predict(_x[i]);
                        int actual = _y[i];
                        if (predicted > 0 && predicted == actual)
                            _tp++;
                        else if (predicted > 0 && predicted != actual)
                            _fp++;
                        else if (predicted <= 0 && predicted == actual)
                            _tn++;
                        else
                            _fn++;
                    }
                }

                String dump() {
                    return String("Support:\t")
                           + support()
                           + "\nTP:\t"
                           + _tp
                           + "\nTN:\t"
                           + _tn
                           + "\nFP:\t"
                           + _fp
                           + "\nFN:\t"
                           + _fn
                           + "\nAccuracy:\t"
                           + accuracy()
                           + "\nPrecision:\t"
                           + precision()
                           + "\nRecall:\t"
                           + recall()
                           + "\nSpecificity:\t"
                           + specificity()
                            ;
                }

                float accuracy() {
                    return (1.0f * _tp + _tn) / support();
                }

                float precision() {
                    return (1.0f * _tp) / (_tp + _fp);
                }

                float recall() {
                    return (1.0f * _tp) / (_tp + _fn);
                }

                float specificity() {
                    return (1.0f * _tn) / (_tn + _fp);
                }

                uint16_t support() {
                    return _tp + _tn + _fp + _fn;
                }

            protected:
                float _x[40][2];
                int _y[40];
                uint16_t _tp, _fp, _tn, _fn;
            };
        }
    }
}